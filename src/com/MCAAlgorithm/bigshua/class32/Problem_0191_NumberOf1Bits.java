package com.MCAAlgorithm.bigshua.class32;

public class Problem_0191_NumberOf1Bits {
    
	// n的二进制形式，有几个1？
	public static int hammingWeight1(int n) {
		int bits = 0;
		int rightOne = 0;
		while(n != 0) {
			bits++;
			rightOne = n & (-n);
			n ^= rightOne;	
		}
		return bits;
	}

	// todo：后面好多地方用位数的地方都会出现这个方法
	// 01>>1== 00  原数、右移结果和01操作求一共多少个1  00 & 01 + 01  & 01 = 1 ，1个1
	// 10 >> 1 = 01 原数、右移结果和01操作求一共多少个1  01 & 01  + 10 & 01 = 1 ，1个1
	// 11 >> 1 = 01 原数、右移结果和01操作求一共多少个   01 & 01 + 11 & 01 = 2，2个1
	// 通过这个结论：两两为可以一起看1的个数有几个，推出32位如何一起看
	// 思路：如果两位一起看有两个1二进制位表示为10，如果两位一起看有1个1，二进制表示为01，合起来是1001
	//  那么推出来四位一起看，这四位一共有3个1，二进制应该表示为0011，如何得到这个结果就是右移动2位与0011与完的结果+原来的数，
	//  即 (1001>>2) & 0011 + 1001 & 0011 = 0010 + 0001 = 0011 = 3
	//  再来一个例子：1010 2个1+2个1 = 4 最后四位结果变成0100，
	//  （1010 >> 2） & 0011 + 1010 & 0011 = 0010 + 0010  = 0100 = 4
	//  四位组合看的例子：0011 0010 = 前4位3个1，后四位2个1，换成8位看有5个1，最终八位结果应该是 = 0000 0101，
	//  如何操作 (00110010>>4) & 00001111 + 00110010 & 00001111 = 00000101=5个
	public static int hammingWeight2(int n) {
		n = (n & 0x55555555) + ((n >>> 1) & 0x55555555);//一位的情况，连着1个1
		n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);//两位的情况，连着两个1
		n = (n & 0x0f0f0f0f) + ((n >>> 4) & 0x0f0f0f0f);//四位位的情况，连着四个1
		n = (n & 0x00ff00ff) + ((n >>> 8) & 0x00ff00ff);//八位的情况，连着八个1
		n = (n & 0x0000ffff) + ((n >>> 16) & 0x0000ffff);//十六位的情况，连着十六个1
		return n;
	}
	
}
