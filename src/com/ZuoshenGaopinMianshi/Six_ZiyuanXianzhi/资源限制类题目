一、【位图】32位无符号整数0~4,294,967,295，现在有一个包含40亿个无符号整数的文件，其中必有没有出现过的数，使用1G内存，找到所有未出现的数。
    回顾1Byte = 8bits，一个整数4字节，正常的话需要16G左右。
    解决方案:使用一个整数数组，每一个数字的每一位表示该数字是否存在 arr[num/32] = arr[num/32] | (1 <<(num%32))
            512MB做出一个位图搞定，遍历文件，位图对应位置描黑

二、单词统计
    线程池划分:(1)读取线程池，负责读取内容 (2)切分线程池，负责切分
    问题:1、如何保证负载均衡。读取线程池:只负责读取字符串的地址，是一个8字节的地址是地址！所以每个读取线程池的负载大小基本差不多。
        切分线程池:如果有A、B、C、D四个线程池，如果某个线程池获得字符串较大，那么该线程的耗时较大。切分线程池如何搞定负载均衡，构造一个
        负载均衡表(优先级队列，堆)，每次新的任务给最小的负载。但是，负载表不好动态维护数据，这不是最优解。最终，最优解使用的是随机函数，
        分配线程池，使用一个等概率随机，每个都几乎平分到每个线程。

三、设计一个UUID系统【颠覆思路:垂直共产党结构，垂直结构的艺术】
    mac+时间戳:面试官直接堵死你，臭傻逼掐死他。同步的路堵死。
    google官方来秀一下:每秒几万亿。假设A机器只维持一个信息:当前分配的UUID是多少。然后中国机器分配(0号开始，170亿个UUID)，这是A机器Start
    信息是170亿+1开始，然后美国要(170亿+1开始，150亿个UUID)。A机器和各地分机进行心跳沟通，保证A机器和下级机器沟通时间越长越好！每次都分一大批出去。
    中国的各省市同理。如果老的河南机器下线，新的加进来继续分，一点点往下分。

四、32位，无符号数，10G的数据量，内存有5G，对数字进行排序
    思路:利用一个小文件，对部分进行排序和统计数量，达到数量进行输出(堆 + hash表统计)。利用有限的5G文件都做这种结构，搞定。

五、32位无符号数，40亿个无符号整数，利用3k内存找到这40亿个数的中位数
   分桶，在3k的范围上均分掉，每3k有多少个变量