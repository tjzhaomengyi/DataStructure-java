一、递归函数调用次数的计算
1、单递归
    递推关系 C(n)=1+C(n-1)
    调用次数 O(n)
    阶乘、链表遍历
2、双递归
    递推关系 C(n) = 1 + C(n-1) + C(n-2)
    调用次数O(2^n)
    斐波那契额数列
3、二分递归
    递推关系 C(n) = 1 + 2C(n/2)
    调用次数 O(n)
    归并排序
4、多路递归
   C(n) = 1 + KC(n-1)
   调用次数 O(k^n)
   组合问题
注意：递归计算中，第一次计算等号左边的算在计算的次数内，剩下的下面递归算式中等号左边的调用都算在上一次递归时候的调用。
例如:
f(9) = f(7)+f(3)
f(7) = f(5)+f(1)
一共调用了5次递归，第二个f(7)不计算在内，它就是第一个式子中的f(7)

二、使用 Master定理 分析递归算法的时间复杂度
T(n) = aT(n/b) + (f(n))^d
a≥1：表示子问题的个数
b>1：表示问题规模缩小比例
f(n): 分解和合并的代价
d: 表示f(n)的阶数
case1：a > b^d O(n)=O(n^log_b a) 叶子节点工作量大
case2：a = b^d O(n)=O(n^d logn) 每层工作量均衡
case3：a < b^d O(n)=O(f(n))=O(n^d) 根节点工作量大


这三种情况怎么去看，例子：
例1：
T(n)=8T(n/2) + n²
a=8 b=2 d=2
叶子：log_2 8 = 3
根 d=2 合并按照n²增长
3 > 2 是 case1 是 O(n³)，叶子节点工作量大

例2：
T(n)=4T(n/2) + n²
a=4 b=2 d=2 ,这里n平方项没有log项，所以log项的指数k=0，所以计算logn的时候只有一层即k+1=1，也就是(logn)^1
叶子： log_2 4 = 2
比较 2=2 是case2 O(n^dlogn)=O(n^2logn^(k+1))，这里平方上的2是用的d的2，叶子和根工作量一样大,logn表示层数

例3：
T(n) = 2T(n/2) + n²
a=2 b=2 d=2
叶子 log_2 2=1
根 d=2
比较 1 < 2 case3 O(n²) 根工作量大，这里平方用的是根节点的2

例4：
T(n) = 8T(n/2)+logn
a = 8, b = 2,
logn = n^0 * (logn)^1
d = 0, k = 1
log_b a = 3
3 > 0,这里叶子节点n^3,根节点的工作量就是logn

三、汉诺塔的递推次数公式
H(n) = 2H(n-1) + 1 ,H(1) = 1
H(n) = 2^n - 1

